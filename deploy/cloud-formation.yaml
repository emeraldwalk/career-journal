AWSTemplateFormatVersion: "2010-09-09"
Description: AWS AppSync Journal API

Parameters:
  APIName:
    Type: String
    Description: Name of the API
    MinLength: 3
    MaxLength: 20
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9_]*$

Resources:
  EntryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${APIName}EntryTable
      AttributeDefinitions:
        -
          AttributeName: id
          AttributeType: S
      KeySchema:
        -
          AttributeName: id
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Name
          Value: !Sub ${APIName}EntryTable

  TagTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${APIName}TagTable
      AttributeDefinitions:
        -
          AttributeName: id
          AttributeType: S
        -
          AttributeName: parentId
          AttributeType: S
      KeySchema:
        -
          AttributeName: id
          KeyType: HASH
        -
          AttributeName: parentId
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Name
          Value: !Sub ${APIName}TagTable

  DynamoDBPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Managed policy to allow AppSync to access DynamoDB tables.
      Path: /appsync/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:DeleteItem
            - dynamodb:UpdateItem
            - dynamodb:Query
            - dynamodb:Scan
            - dynamodb:BatchGetItem
            - dynamodb:BatchWriteItem
            Resource:
            - !Join [ "", [ !GetAtt EntryTable.Arn, "*" ] ]
            - !Join [ "", [ !GetAtt TagTable.Arn, "*" ] ]

  DynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${APIName}-appsync-dynamodb-role
      ManagedPolicyArns:
        - Ref: DynamoDBPolicy
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com
    DependsOn:
      - DynamoDBPolicy

  UserPool:
    Type: AWS::Cognito::UserPool
    Description: User pool for authenticating api users.
    Properties:
      UserPoolName: !Sub ${APIName}-user-pool
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: False
          RequireNumbers: True
          RequireSymbols: False
          RequireUppercase: True
      UserPoolTags:
        Name: !Sub ${APIName}-user-pool

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Description: App client used by AppSync api.
    Properties:
      ClientName: !Sub ${APIName}-appsync-client
      GenerateSecret: false
      UserPoolId: !Ref UserPool

  AppSyncApi:
    Type: AWS::AppSync::GraphQLApi
    Description: The AppSync api.
    Properties:
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      Name: !Sub ${APIName}
      UserPoolConfig:
        # The tutorial showed this pointing to the UserPoolClient
        # but it seems this should point to the UserPool
        UserPoolId: !Ref UserPool
        AwsRegion: !Sub ${AWS::Region}
        DefaultAction: ALLOW

  AppSyncSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      Definition: |
        input CreateEntryInput {
          categoryTags: AWSJSON!
          content: AWSJSON!
          createdAt: AWSDateTime
          date: AWSDate!
          tags: [String!]!
          title: String!
          updatedAt: AWSDateTime
        }

        input CreateTagInput {
          icon: String
          parentId: ID!
          value: String!
        }

        input DeleteEntryInput {
          id: ID!
        }

        input DeleteTagInput {
          id: ID!
          parentId: ID!
        }

        type Entry {
          categoryTags: AWSJSON!
          content: AWSJSON!
          createdAt: AWSDateTime
          date: AWSDate!
          id: ID!
          tags: [String!]!
          title: String!
          updatedAt: AWSDateTime
        }

        type EntryConnection {
          items: [Entry!]!
          nextToken: String
        }

        type Mutation {
          createEntry(input: CreateEntryInput!): Entry!
          createTag(input: CreateTagInput!): Tag!
          deleteEntry(input: DeleteEntryInput!): Entry!
          deleteTag(input: DeleteTagInput!): Tag!
          updateEntry(input: UpdateEntryInput!): Entry!
          updateTag(input: UpdateTagInput!): Tag!
        }

        type Query {
          getEntry(id: ID!): Entry
          getTag(id: ID!, parentId: ID!): Tag
          listEntries(filter: TableEntryFilterInput, limit: Int, nextToken: String): EntryConnection!
          listTags(filter: TableTagFilterInput, limit: Int, nextToken: String): TagConnection!
        }

        type Subscription {
          onCreateEntry(
            createdAt: AWSDateTime,
            date: AWSDate,
            id: ID,
            tags: [String!],
            title: String
          ): Entry
            @aws_subscribe(mutations: ["createEntry"])
          onCreateTag(
            icon: String,
            id: ID,
            parentId: ID,
            value: String
          ): Tag
            @aws_subscribe(mutations: ["createTag"])
          onDeleteEntry(
            createdAt: AWSDateTime,
            date: AWSDate,
            id: ID,
            tags: [String!],
            title: String
          ): Entry
            @aws_subscribe(mutations: ["deleteEntry"])
          onDeleteTag(
            icon: String,
            id: ID,
            parentId: ID,
            value: String
          ): Tag
            @aws_subscribe(mutations: ["deleteTag"])
          onUpdateEntry(
            createdAt: AWSDateTime,
            date: AWSDate,
            id: ID,
            tags: [String!],
            title: String
          ): Entry
            @aws_subscribe(mutations: ["updateEntry"])
          onUpdateTag(
            icon: String,
            id: ID,
            parentId: ID,
            value: String
          ): Tag
            @aws_subscribe(mutations: ["updateTag"])
        }

        input TableBooleanFilterInput {
          eq: Boolean
          ne: Boolean
        }

        input TableEntryFilterInput {
          createdAt: TableStringFilterInput
          date: TableStringFilterInput
          id: TableIDFilterInput
          tags: TableStringFilterInput
          title: TableStringFilterInput
          updatedAt: TableStringFilterInput
        }

        input TableFloatFilterInput {
          between: [Float]
          contains: Float
          eq: Float
          ge: Float
          gt: Float
          le: Float
          lt: Float
          ne: Float
          notContains: Float
        }

        input TableIDFilterInput {
          beginsWith: ID
          between: [ID]
          contains: ID
          eq: ID
          ge: ID
          gt: ID
          le: ID
          lt: ID
          ne: ID
          notContains: ID
        }

        input TableIntFilterInput {
          between: [Int]
          contains: Int
          eq: Int
          ge: Int
          gt: Int
          le: Int
          lt: Int
          ne: Int
          notContains: Int
        }

        input TableStringFilterInput {
          beginsWith: String
          between: [String]
          contains: String
          eq: String
          ge: String
          gt: String
          le: String
          lt: String
          ne: String
          notContains: String
        }

        input TableTagFilterInput {
          icon: TableStringFilterInput
          id: TableIDFilterInput
          parentId: TableIDFilterInput
          value: TableStringFilterInput
        }

        type Tag {
          icon: String
          id: ID!
          parentId: ID!
          value: String!
        }

        type TagConnection {
          items: [Tag!]!
          nextToken: String
        }

        input UpdateEntryInput {
          categoryTags: AWSJSON
          content: AWSJSON,
          createdAt: AWSDateTime
          date: AWSDate!
          id: ID!
          tags: [String!]
          title: String!
          updatedAt: AWSDateTime
        }

        input UpdateTagInput {
          icon: String
          id: ID!
          parentId: ID!
          value: String!
        }

        schema {
          query: Query
          mutation: Mutation
          subscription: Subscription
        }

  AppSyncEntryTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      Name: !Sub ${APIName}_entry_table
      Description: The entry table AppSync data source
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt DynamoDBRole.Arn
      DynamoDBConfig:
        TableName: !Ref EntryTable
        AwsRegion: !Sub ${AWS::Region}

  AppSyncTagTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      Name: !Sub ${APIName}_tag_table
      Description: The tag table AppSync data source
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt DynamoDBRole.Arn
      DynamoDBConfig:
        TableName: !Ref TagTable
        AwsRegion: !Sub ${AWS::Region}

  AppSyncListEntriesQueryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Query
      FieldName: listEntries
      DataSourceName: !GetAtt AppSyncEntryTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "Scan",
          "filter": #if($context.args.filter) $util.transform.toDynamoDBFilterExpression($ctx.args.filter) #else null #end,
          "limit": $util.defaultIfNull($ctx.args.limit, 20),
          "nextToken": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null)),
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncGetEntryQueryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Query
      FieldName: getEntry
      DataSourceName: !GetAtt AppSyncEntryTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.id),
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncCreateEntryMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: createEntry
      DataSourceName: !GetAtt AppSyncEntryTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($util.autoId()),
          },
          "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),
          "condition": {
            "expression": "attribute_not_exists(#id)",
            "expressionNames": {
              "#id": "id",
            },
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncDeleteEntryMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: deleteEntry
      DataSourceName: !GetAtt AppSyncEntryTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "DeleteItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncUpdateEntryMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: updateEntry
      DataSourceName: !GetAtt AppSyncEntryTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "UpdateItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),
          },

          ## Set up some space to keep track of things we're updating **
          #set( $expNames  = {} )
          #set( $expValues = {} )
          #set( $expSet = {} )
          #set( $expAdd = {} )
          #set( $expRemove = [] )

          ## Iterate through each argument, skipping keys **
          #foreach( $entry in $util.map.copyAndRemoveAllKeys($ctx.args.input, ["id"]).entrySet() )
            #if( $util.isNull($entry.value) )
              ## If the argument is set to "null", then remove that attribute from the item in DynamoDB **

              #set( $discard = ${expRemove.add("#${entry.key}")} )
              $!{expNames.put("#${entry.key}", "${entry.key}")}
            #else
              ## Otherwise set (or update) the attribute on the item in DynamoDB **

              $!{expSet.put("#${entry.key}", ":${entry.key}")}
              $!{expNames.put("#${entry.key}", "${entry.key}")}
              $!{expValues.put(":${entry.key}", $util.dynamodb.toDynamoDB($entry.value))}
            #end
          #end

          ## Start building the update expression, starting with attributes we're going to SET **
          #set( $expression = "" )
          #if( !${expSet.isEmpty()} )
            #set( $expression = "SET" )
            #foreach( $entry in $expSet.entrySet() )
              #set( $expression = "${expression} ${entry.key} = ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Continue building the update expression, adding attributes we're going to ADD **
          #if( !${expAdd.isEmpty()} )
            #set( $expression = "${expression} ADD" )
            #foreach( $entry in $expAdd.entrySet() )
              #set( $expression = "${expression} ${entry.key} ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Continue building the update expression, adding attributes we're going to REMOVE **
          #if( !${expRemove.isEmpty()} )
            #set( $expression = "${expression} REMOVE" )

            #foreach( $entry in $expRemove )
              #set( $expression = "${expression} ${entry}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Finally, write the update expression into the document, along with any expressionNames and expressionValues **
          "update": {
            "expression": "${expression}",
            #if( !${expNames.isEmpty()} )
              "expressionNames": $utils.toJson($expNames),
            #end
            #if( !${expValues.isEmpty()} )
              "expressionValues": $utils.toJson($expValues),
            #end
          },

          "condition": {
            "expression": "attribute_exists(#id)",
            "expressionNames": {
              "#id": "id",
            },
          }
        }

      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncListTagsQueryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Query
      FieldName: listTags
      DataSourceName: !GetAtt AppSyncTagTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "Scan",
          "filter": #if($context.args.filter) $util.transform.toDynamoDBFilterExpression($ctx.args.filter) #else null #end,
          "limit": $util.defaultIfNull($ctx.args.limit, 20),
          "nextToken": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null)),
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncGetTagQueryResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Query
      FieldName: getTag
      DataSourceName: !GetAtt AppSyncTagTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.id),
            "parentId": $util.dynamodb.toDynamoDBJson($ctx.args.parentId),
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncCreateTagMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: createTag
      DataSourceName: !GetAtt AppSyncTagTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($util.autoId()),
            "parentId": $util.dynamodb.toDynamoDBJson($util.defaultIfNull($ctx.args.input.parentId, "__ROOT__"))
          },
          "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),
          "condition": {
            "expression": "attribute_not_exists(#id)",
            "expressionNames": {
              "#id": "id",
            },
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncDeleteTagMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: deleteTag
      DataSourceName: !GetAtt AppSyncTagTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "DeleteItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),
            "parentId": $util.dynamodb.toDynamoDBJson($ctx.args.input.parentId),
          },
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

  AppSyncUpdateTagMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: AppSyncSchema
    Properties:
      ApiId: !GetAtt AppSyncApi.ApiId
      TypeName: Mutation
      FieldName: updateTag
      DataSourceName: !GetAtt AppSyncTagTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "UpdateItem",
          "key": {
            "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),
            "parentId": $util.dynamodb.toDynamoDBJson($ctx.args.input.parentId),
          },

          ## Set up some space to keep track of things we're updating **
          #set( $expNames  = {} )
          #set( $expValues = {} )
          #set( $expSet = {} )
          #set( $expAdd = {} )
          #set( $expRemove = [] )

          ## Iterate through each argument, skipping keys **
          #foreach( $entry in $util.map.copyAndRemoveAllKeys($ctx.args.input, ["id", "parentId"]).entrySet() )
            #if( $util.isNull($entry.value) )
              ## If the argument is set to "null", then remove that attribute from the item in DynamoDB **

              #set( $discard = ${expRemove.add("#${entry.key}")} )
              $!{expNames.put("#${entry.key}", "${entry.key}")}
            #else
              ## Otherwise set (or update) the attribute on the item in DynamoDB **

              $!{expSet.put("#${entry.key}", ":${entry.key}")}
              $!{expNames.put("#${entry.key}", "${entry.key}")}
              $!{expValues.put(":${entry.key}", $util.dynamodb.toDynamoDB($entry.value))}
            #end
          #end

          ## Start building the update expression, starting with attributes we're going to SET **
          #set( $expression = "" )
          #if( !${expSet.isEmpty()} )
            #set( $expression = "SET" )
            #foreach( $entry in $expSet.entrySet() )
              #set( $expression = "${expression} ${entry.key} = ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Continue building the update expression, adding attributes we're going to ADD **
          #if( !${expAdd.isEmpty()} )
            #set( $expression = "${expression} ADD" )
            #foreach( $entry in $expAdd.entrySet() )
              #set( $expression = "${expression} ${entry.key} ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Continue building the update expression, adding attributes we're going to REMOVE **
          #if( !${expRemove.isEmpty()} )
            #set( $expression = "${expression} REMOVE" )

            #foreach( $entry in $expRemove )
              #set( $expression = "${expression} ${entry}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end

          ## Finally, write the update expression into the document, along with any expressionNames and expressionValues **
          "update": {
            "expression": "${expression}",
            #if( !${expNames.isEmpty()} )
              "expressionNames": $utils.toJson($expNames),
            #end
            #if( !${expValues.isEmpty()} )
              "expressionValues": $utils.toJson($expValues),
            #end
          },

          "condition": {
            "expression": "attribute_exists(#id) AND attribute_exists(#parentId)",
            "expressionNames": {
              "#id": "id",
              "#parentId": "parentId",
            },
          }
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result)

Outputs:
  EntryTableName:
    Description: The name of the Entry table
    Value: !Ref EntryTable
  TagTableName:
    Description: The name of the Tag table
    Value: !Ref TagTable
  CognitoUserPoolId:
    Description: The Pool ID of the Cognito User Pool
    Value: !Ref UserPool
  CognitoUserPoolClientId:
    Description: The Client ID for AWS AppSync Auth
    Value: !Ref UserPoolClient